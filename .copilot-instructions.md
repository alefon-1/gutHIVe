# gutHIVe - Copilot Instructions

## Project Overview

**gutHIVe** is an ambitious project to create an honest, working competitor to GitHub without any hidden functionality or UI pain points. This repository serves as the foundation for building a transparent, user-focused code hosting and collaboration platform.

### Project Mission
- **Honesty**: Complete transparency in all functionality with no hidden features
- **User Experience**: Eliminate the UI pain points and frustrations found in existing platforms
- **Open Development**: All development processes and decisions should be transparent
- **Community-Driven**: Built by and for developers who want a better experience

### Core Principles
- Transparency over secrecy
- Simplicity over complexity
- User needs over business metrics
- Performance over feature bloat
- Security through openness

## Repository Context

- **Current Stage**: Early development/planning phase
- **Target Audience**: Developers, open source contributors, teams seeking GitHub alternatives
- **Technology Stack**: To be determined based on requirements (likely web-based platform)
- **Development Model**: Open source, community-driven development

## Development Guidelines

### Code Quality Standards
- Write clean, readable, and well-documented code
- Prioritize maintainability and extensibility
- Follow language-specific conventions and best practices
- Include comprehensive tests for all functionality
- Document all public APIs and interfaces

### User Experience Focus
- Every feature must solve a real user problem
- UI/UX decisions should prioritize developer workflows
- Eliminate unnecessary friction in common tasks
- Provide clear feedback and error messages
- Ensure accessibility and inclusive design

### Transparency Requirements
- All algorithms and business logic must be open and documented
- No hidden tracking or analytics without explicit user consent
- Clear documentation of all data collection and usage
- Open roadmap and decision-making processes
- Regular community updates and communication

## Architecture Guidelines

### Design Principles
- **Modularity**: Build loosely coupled, highly cohesive components
- **Scalability**: Design for growth from day one
- **Performance**: Optimize for speed and efficiency
- **Security**: Security by design, not as an afterthought
- **Reliability**: Build robust systems that handle failures gracefully

### Technology Considerations
When selecting technologies, prioritize:
- Open source solutions over proprietary ones
- Well-established, actively maintained projects
- Performance and scalability characteristics
- Developer experience and ease of contribution
- Community support and documentation quality

## Feature Development Process

### Before Adding New Features
1. Validate the need with user research or community feedback
2. Consider how this improves upon existing GitHub functionality
3. Design with transparency and user control in mind
4. Plan for comprehensive testing and documentation
5. Consider performance and security implications

### Implementation Standards
- Start with minimal viable implementation
- Write tests before or alongside feature code
- Document all configuration options and behaviors
- Include migration paths for data/settings
- Provide clear user documentation

## Contribution Guidelines

### Code Review Standards
- All changes must be reviewed by at least one other contributor
- Focus on code quality, security, and user impact
- Ensure changes align with project mission and principles
- Verify adequate testing and documentation
- Check for accessibility and performance considerations

### Documentation Requirements
- Update relevant documentation with any changes
- Include clear examples and use cases
- Document any breaking changes or migration steps
- Maintain up-to-date API documentation
- Keep README and setup instructions current

### Commit Message Format
Use conventional commits for clear change tracking:
```
<type>(<scope>): <description>

[optional body]

[optional footer]
```

Types: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`
Scopes: `ui`, `api`, `auth`, `storage`, `search`, `ci`, etc.

### Testing Requirements
- Unit tests for all business logic
- Integration tests for API endpoints
- UI/UX tests for critical user workflows
- Performance tests for scalability validation
- Security tests for authentication and authorization

## Security and Privacy

### Security Standards
- Follow OWASP guidelines for web application security
- Implement secure authentication and authorization
- Use HTTPS everywhere with proper certificate management
- Regular security audits and vulnerability assessments
- Secure coding practices and input validation

### Privacy Protection
- Minimal data collection with explicit user consent
- Clear privacy policy and data usage documentation
- User control over their data and privacy settings
- Right to data portability and deletion
- No third-party tracking without user awareness

## Performance Standards

### Response Time Targets
- Page loads: < 2 seconds for 95th percentile
- API responses: < 500ms for common operations
- Search functionality: < 1 second for typical queries
- File operations: Optimize for large repositories

### Scalability Considerations
- Design for horizontal scaling from the start
- Efficient database queries and caching strategies
- CDN integration for static assets
- Monitoring and alerting for performance regression

## UI/UX Guidelines

### Design Philosophy
- Clean, intuitive interfaces that prioritize functionality
- Consistent visual language and interaction patterns
- Reduce cognitive load and eliminate unnecessary steps
- Mobile-responsive design for all features
- Dark mode and accessibility support

### Common GitHub Pain Points to Avoid
- Confusing navigation and hidden features
- Slow or unresponsive interfaces
- Unclear error messages and feedback
- Complex workflows for simple tasks
- Poor mobile experience

## Technology Stack Guidelines

### Backend Development
- RESTful API design with clear documentation
- Proper error handling and status codes
- Efficient database schema and query optimization
- Caching strategies for frequently accessed data
- Background job processing for heavy operations

### Frontend Development
- Progressive enhancement and graceful degradation
- Efficient state management and data flow
- Optimized asset loading and caching
- Responsive design for all screen sizes
- Keyboard navigation and screen reader support

### Database Design
- Normalized schema with appropriate indexes
- Efficient queries and data access patterns
- Regular backup and disaster recovery procedures
- Data migration strategies for schema changes
- Performance monitoring and optimization

## Community and Communication

### Open Development Process
- Public roadmap with community input
- Regular progress updates and development blogs
- Open issue tracking and feature requests
- Community meetings and feedback sessions
- Transparent decision-making documentation

### Contribution Recognition
- Clear attribution for all contributors
- Regular acknowledgment of community contributions
- Mentorship opportunities for new contributors
- Documentation of contribution guidelines
- Recognition of different types of contributions

## Future Considerations

### Planned Feature Areas
- Repository hosting and version control
- Issue tracking and project management
- Pull request workflow and code review
- Continuous integration and deployment
- Package and artifact management
- User authentication and authorization
- Search and discovery functionality
- API and integrations platform

### Extensibility
- Plugin architecture for third-party extensions
- Webhook system for external integrations
- API-first design for headless usage
- Theme and customization support
- Self-hosting options for organizations

## Quality Assurance

### Testing Strategy
- Automated testing in CI/CD pipeline
- Manual testing for critical user workflows
- Performance testing under load
- Security penetration testing
- Accessibility compliance testing

### Monitoring and Observability
- Application performance monitoring
- Error tracking and alerting
- User behavior analytics (with consent)
- Infrastructure monitoring and alerting
- Regular health checks and status reporting

## Updates and Maintenance

### Keeping Instructions Current
- Review and update these instructions quarterly
- Incorporate feedback from development team
- Adapt guidelines as project and technology evolve
- Maintain alignment with project mission and goals
- Document any changes and rationale

---

*These instructions should evolve with the project. All contributors are encouraged to suggest improvements that better serve our mission of building an honest, transparent GitHub alternative.*

**Last Updated**: September 2025
**Version**: 1.0.0